/**
 * 04-05-01.js - a simple JavaScript file that gets loaded with
 * page 5 of Workbook 4 (CS559).
 *
 * written by Michael Gleicher, January 2019
 * modified January 2020, February 2021
 *
 */

/**
 * NOTES TO GRADER
 * -> LLM Statement: Code that has been generated by ChatGPT is denoted with a (!) and will specify which
 *    specific lines were developed by a LLM. These segments will have comments explaining
 *    what is happening to ensure that I know what the code is doing and how it works in my code.
 * 
 * -> My description: I created roly polies that collide with both each other and with strawberries! :)
 * 
 * SOURCES
 * BEZIER CURVES: https://javascript.info/bezier-curve
 * MATH ATAN2: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/atan2 
 * Lots of information from Young wu's slides were also used. 
 */

/**
 * Class to create Obstacles 
 */
class Obstacle {
    /**
     * constructor for Obstacle objects (strawberries); requires and x and y coordinate position (where it will be 
     * translated to), an angle at which the strawberry will be rotated, and what scale factors the strawberry
     * should be scaled to.
     * 
     * @param {number} x 
     * @param {number} y 
     * @param {number} angle 
     * @param {number} scaleX 
     * @param {number} scaleY 
     */
    constructor(x, y, angle, scaleX, scaleY) {
        this.x = x;
        this.y = y;
        this.angle = angle;
        this.scaleX = scaleX;
        this.scaleY = scaleY;
    }
}
/**
 * Class to create Boids
 */
class Boid {
    /**
     * class for Boids that takes in an x,y position and x and y velocities
     * 
     * @param {number} x    - initial X position
     * @param {number} y    - initial Y position
     * @param {number} vx   - initial X velocity
     * @param {number} vy   - initial Y velocity
     */
    constructor(x, y, vx = 1, vy = 0) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        //variables for color & color change
        this.color = "grey";
        this.originalColor = "grey";
        //because bugs would collide with each other and get stuck to each other, I
        //found a solution such that they have a very short period of invulnerability
        //so they are able to move away before colliding again. this period is 100MS 
        //(as described in the actual code part). this boolean field will help to
        //determine when they are or are not invulnerable.
        this.invulnerable = false;
        //latestCollision is used to understand when the last collision was. we use this
        //to update both color and invulnerability.
        this.latestCollision = 0;
    }
    /**
     * Draw the Boid
     * @param {CanvasRenderingContext2D} context 
     */
    draw(context) {
        context.save();
        //translate and rotate the boid based on the boid data fields in the constructor
        context.translate(this.x, this.y);
        context.rotate(Math.atan2(this.vy, this.vx));
        context.fillStyle = this.color;
        context.strokeStyle = "black";

        //BUG BODY
        context.beginPath();
        context.ellipse(0, 0, 20, 10, 0, 0, 2 * Math.PI);
        context.stroke();
        context.fill();

        //BUG LINES
        context.strokeStyle = "black";
        context.beginPath();
        context.moveTo(8, 9);
        context.lineTo(8, -9);
        context.stroke();
        context.closePath();

        context.beginPath();
        context.moveTo(2, 10);
        context.lineTo(2, -10);
        context.stroke();
        context.closePath();

        context.beginPath();
        context.moveTo(-4, 10);
        context.lineTo(-4, -10);
        context.stroke();
        context.closePath();

        context.beginPath();
        context.moveTo(-10, 9);
        context.lineTo(-10, -9);
        context.stroke();
        context.closePath();

        //BUG LEGS
        // (!) LINE 123 IS GENERATED FROM CHAT GPT. line 123 uses the function of time (performance.now()) in
        //and scales it down by 40 so that it performs better in the sin function. the sin function essentially is what makes it
        //oscillate. it oscillates between -30 degrees and 30 degrees (because of the Math.PI / 6 multiplication)
        const legAngle = Math.sin(performance.now() / 40) * Math.PI / 6;
        context.lineWidth = 3;
        context.beginPath();
        context.moveTo(12, -8);
        //pass the angle from before into the outer edge of the leg so that it can oscillate
        context.lineTo(8 + 6 * legAngle, -17);
        context.stroke();
        context.closePath();

        context.lineWidth = 3;
        context.beginPath();
        context.moveTo(12, 8);
        context.lineTo(8 + 6 * Math.sin(legAngle), 17);
        context.stroke();
        context.closePath();

        context.beginPath();
        context.moveTo(0, -8);
        context.lineTo(-4 + 6 * Math.sin(legAngle + 10), -17);
        context.stroke();
        context.closePath();

        context.beginPath();
        context.moveTo(0, 8);
        context.lineTo(-4 + 6 * Math.sin(legAngle + 10), 17);
        context.stroke();
        context.closePath();

        //ANTENNAS
        context.beginPath();
        context.moveTo(15, 6);
        context.lineTo(25, 6);
        context.quadraticCurveTo(30, 7, 28, 12);
        context.stroke();

        context.beginPath();
        context.moveTo(15, -6);
        context.lineTo(25, -6);
        context.quadraticCurveTo(30, -7, 28, -12);
        context.stroke();

        context.restore();
    }

    /**
     * Perform the "steering" behavior -
     * This function should update the velocity based on the other
     * members of the flock.
     * It is passed the entire flock (an array of Boids) - that includes
     * "this"!
     * Note: dealing with the boundaries does not need to be handled here
     * (in fact it can't be, since there is no awareness of the canvas)
     * *
     * And remember, (vx,vy) should always be a unit vector!
     * @param {Array<Boid>} flock 
     */
    steer(flock, obstacles) {
        //use random with max frequency of 0.02 (executes ~2% of the time) to have the bugs shift slightly while walking
        if (Math.random() < 0.02) {
            //the maximum angle change 
            const maxAngleChange = Math.PI / 90;
            const angleChange = (Math.random() - 0.5) * 2 * maxAngleChange;
            //(!) THE FOLLOWING TWO LINES WERE PARTIALLY GENERATED BY CHAT GPT
            //these lines calculate the new horizontal and vertical components and does so through
            //first multiplying each angle change by the vertical or horizontal component (this preserves the magnitude - see
            //more about magnitude around line 480). the reason why we use both cos and sin
            //in both the new VX and new VY is because vx and vy both have a vertical AND horizontal
            //coponent. We add in the first one because we want to contribute positively to the new
            //HORIZONTAL velocity and we subtract in the second one because we want to contribute NEGATIVELY to
            //the horizontal velocity.
            const newVX = this.vx * Math.cos(angleChange) - this.vy * Math.sin(angleChange);
            const newVY = this.vx * Math.sin(angleChange) + this.vy * Math.cos(angleChange);
            //upadate vx and vy with these new values
            this.vx = newVX;
            this.vy = newVY;
        }

        //COLLISION HANDLING FOR OTHER BOIDS
        flock.forEach(collisionBoid => {
            //if the collision boid is NOT the same as the boid we are comparing in this for loop, and if
            //the boid is not vulnerable (see more about vulnerability in the variable declaration), then we 
            //want to act upon the collision
            if (collisionBoid !== this && !this.invulnerable) {
                //calculate distance between the boids in both x and y direction
                const distX = collisionBoid.x - this.x;
                const distY = collisionBoid.y - this.y;
                //calculate the distance using the distance formula
                const distance = Math.sqrt(distX * distX + distY * distY);

                //if the distance is less than 30 (personal preference based on visual input), then we will consider
                //these two boids close enough to bounce away from each other
                if (distance < 30) {
                    //calculate the angle between the x axis and the colliding boid (will help us determine which direction to bounce from)
                    const collisionAngle = Math.atan2(distY, distX);
                    //(!) NEXT 4 LINES PARTIALLY WRITTEN BY CHAT GPT. these lines are written by me, but I referred to the two CHAT-GPT lines above
                    //that are marked. therefore, this is inspired by chat gpt.
                    //calculate new direction vectors for both the current boid and the colliding boid (since we want them to both
                    //bounce away from each other)
                    const newVX1 = Math.cos(collisionAngle) * this.vx + Math.sin(collisionAngle) * this.vy;
                    const newVY1 = -Math.sin(collisionAngle) * this.vx + Math.cos(collisionAngle) * this.vy;
                    const newVX2 = Math.cos(collisionAngle) * collisionBoid.vx + Math.sin(collisionAngle) * collisionBoid.vy;
                    const newVY2 = -Math.sin(collisionAngle) * collisionBoid.vx + Math.cos(collisionAngle) * collisionBoid.vy;
                    //update using these new points
                    this.vx = newVX1;
                    this.vy = newVY1;
                    collisionBoid.vx = newVX2;
                    collisionBoid.vy = newVY2;
                    //if we have collided we want to change the color briefly (this will be changed back in the very last if statement
                    //in this segment)
                    this.color = "#7d715f";
                    //since we have collided, we want to stay vulnerable for a short period of time (read more about vulnerability in the variable declaration)
                    this.invulnerable = true;
                    //update latest collision ; read about this in it's variable declaration
                    this.latestCollision = performance.now();
                }
            }

        });

        //COLLISION HANDLING FOR OBSTACLES (strawberries)
        obstacles.forEach(obstacle => {
            //we only want to act upon a collision if the boid (accessed using this keyword) is not vulnerable
            if (!this.invulnerable) {
                //THIS CODE MIRRORS THE CODE FOR BOID COLLISIONS - please read there for inline comment descriptors.
                const distX = obstacle.x - this.x;
                const distY = obstacle.y - this.y;
                const distance = Math.sqrt(distX * distX + distY * distY);
                //distance of 60 is a personal choice based on visual input
                if (distance < 60) {
                    const collisionAngle = Math.atan2(distY, distX);
                    //(!) NEXT TWO LINES PARTIALLY GENERATED BY CHAT GPT - I wrote these lines myself, but they were based off
                    //of lines that I took from chatGPT (which is mentioned above on line 171).
                    const newVX1 = Math.cos(collisionAngle) * this.vx + Math.sin(collisionAngle) * this.vy;
                    const newVY1 = -Math.sin(collisionAngle) * this.vx + Math.cos(collisionAngle) * this.vy;
                    this.vx = newVX1;
                    this.vy = newVY1;
                    this.color = "#7d715f";
                    this.invulnerable = true;
                    this.latestCollision = performance.now();
                }
            }
        });

        //WRAP AROUND AT BORDERS
        //if the y coordinate is less than 0 (above the canvas) or >= canvas height (below the canvas)
        //then we want to update only the y component
        if (this.y <= 0 || this.y >= canvas.height) {
            this.vy *= -1;
            //we want to change the color if it collides - see if statement at the
            //bottom to see when it changes back to original color
            this.color = "#7d715f";
            //if we have made a collision, we want to keep track of when it happened 
            //(so we can update other things)
            this.invulnerable = true;
            //we also want to set invulnerable to true please see explanation in the
            //variable declaration of "invulnerable" to understand what that field does.
            this.latestCollision = performance.now();
        }

        //if the x coordinate is less than 0 (above the canvas) or >= canvas height (below the canvas)
        //then we want to update only the x component
        if (this.x <= 0 || this.x >= canvas.width) {
            this.vx *= -1;
            this.color = "#7d715f";
            this.invulnerable = true;
            this.latestCollision = performance.now();
        }

        //if the time elapsed since the collision is greater than 100 milliseconds (personal preference), then change
        //the color back to its original color, and make the bug no longer invulnerable to collisions
        if (this.invulnerable && (performance.now() - this.latestCollision) > 100) {
            this.invulnerable = false;
            this.color = this.originalColor;
        }
    }
}
/** the actual main program
 * this used to be inside of a function definition that window.onload
 * was set to - however, now we use defer for loading
 */

/** @type Array<Boid> */
let boids = [];
let obstacles = [];
let canvas = /** @type {HTMLCanvasElement} */ (document.getElementById("flock"));
let context = canvas.getContext("2d");
let speedSlider = /** @type {HTMLInputElement} */ (document.getElementById("speed"));


function draw() {
    canvas.style.backgroundColor = "#c4b7a1";
    context.clearRect(0, 0, canvas.width, canvas.height);
    boids.forEach(boid => boid.draw(context));
    obstacles.forEach(obstacle => {
        //drawing the obstacle - using the obstacle data fields to translate, rotate, & scale.
        //my obstacles represent strawberries (which is why this code is very long!)
        context.fillStyle = "#3a5e3e";
        context.save();
        //translate, rotate, and scale based on the data fields in each obstacle (from the constructor)
        context.translate(obstacle.x, obstacle.y);
        context.rotate(obstacle.angle);
        context.scale(obstacle.scaleX, obstacle.scaleY);
        //STRAWBERRY LEAVES:
        context.beginPath();
        context.moveTo(- 20, - 12);
        context.lineTo(-30, -30);
        context.lineTo(-10, -27);
        context.closePath();
        context.fill();

        context.beginPath();
        context.moveTo(-10, -28);
        context.lineTo(-9, -42);
        context.lineTo(0, -30);
        context.closePath();
        context.fill();

        context.beginPath();
        context.moveTo(2, -30);
        context.lineTo(7, -42);
        context.lineTo(15, -24);
        context.closePath();
        context.fill();

        context.beginPath();
        context.moveTo(2, - 22);
        context.lineTo(33, - 28);
        context.lineTo(23, 12);
        context.fill();

        //STRAWBERRY BODY (main circle - does not include tip)
        context.fillStyle = "#85221b";
        context.beginPath();
        context.ellipse(0, 0, 30, 30, 0, 0, 2 * Math.PI);
        context.closePath();
        context.fill();

        //STRAWBERRY END OF BODY (bezier curve to create a nice and realistic looking end of a strawberry)
        context.beginPath();
        context.bezierCurveTo(- 28, 10, 0, 80, 28, 10);
        context.closePath();
        context.fill();

        //STRAWBERRY SEEDS
        context.fillStyle = "#241e13";
        context.beginPath();
        context.ellipse(- 20, 0, 1.5, 1.5, 0, 0, 2 * Math.PI);
        context.closePath();
        context.fill();

        context.beginPath();
        context.ellipse(- 6, - 7, 1.5, 1.5, 0, 0, 2 * Math.PI);
        context.closePath();
        context.fill();

        context.beginPath();
        context.ellipse(6, - 20, 1.5, 1.5, 0, 0, 2 * Math.PI);
        context.closePath();
        context.fill();

        context.beginPath();
        context.ellipse(- 15, - 17, 1.5, 1.5, 0, 0, 2 * Math.PI);
        context.closePath();
        context.fill();

        context.beginPath();
        context.ellipse(0, 10, 1.5, 1.5, 0, 0, 2 * Math.PI);
        context.closePath();
        context.fill();

        context.beginPath();
        context.ellipse(20, -12, 1.5, 1.5, 0, 0, 2 * Math.PI);
        context.closePath();
        context.fill();

        context.beginPath();
        context.ellipse(11, 0, 1.5, 1.5, 0, 0, 2 * Math.PI);
        context.closePath();
        context.fill();

        context.beginPath();
        context.ellipse(20, 10, 1.5, 1.5, 0, 0, 2 * Math.PI);
        context.closePath();
        context.fill();

        context.beginPath();
        context.ellipse(-15, 16, 1.5, 1.5, 0, 0, 2 * Math.PI);
        context.closePath();
        context.fill();

        context.beginPath();
        context.ellipse(-4, 28, 1.5, 1.5, 0, 0, 2 * Math.PI);
        context.closePath();
        context.fill();

        context.beginPath();
        context.ellipse(12, 25, 1.5, 1.5, 0, 0, 2 * Math.PI);
        context.closePath();
        context.fill();

        //INVISIBLE SQUARE - this is used because the strawberry dimensions are very odd
        //which causes issues with how the boid collides with it. this makes collisions simpler
        //transparency is set to 0 for aesthetic purposes, so we can still see the strawberry!
        context.fillStyle = `rgba(255,255,255,0)`;
        context.fillRect(-70, -43, 108, 130)

        context.restore();
    })

}
/**
 * Create initial boids & obstacles
 */
for (let i = 0; i < 4; i++) {
    //use random positions & angle to start with
    let initXPosition = Math.random() * canvas.width;
    let initYPosition = Math.random() * canvas.height;
    let initAngle = Math.random() * Math.PI * 2;
    let xVector = Math.cos(initAngle);
    let yVector = Math.sin(initAngle);
    let newBoid = new Boid(initXPosition, initYPosition, xVector, yVector);
    //make sure to push the boids to the array!
    boids.push(newBoid);

}
//push new obstacles and my preferred locations & angles (aesthetic purposes)
obstacles.push(new Obstacle(150, 150, -Math.PI / 10, 1, 1));
obstacles.push(new Obstacle(350, 400, Math.PI / 10, 0.9, 0.9));
obstacles.push(new Obstacle(500, 70, Math.PI / 10, 0.85, 0.85));
obstacles.push(new Obstacle(60, 500, -Math.PI / 10, 0.85, 0.85));
obstacles.push(new Obstacle(550, 550, Math.PI / 10, 0.85, 0.85));

/**
 * Handle the buttons
 */
document.getElementById("add").onclick = function () {
    //add 10 new boids using a for loop
    for (let i = 0; i < 10; i++) {
        //calculate random x,y positions and angle.
        let initialX = Math.random() * canvas.width;
        let initialY = Math.random() * canvas.height;
        let initialAngle = Math.random() * Math.PI * 2;
        let xVector = Math.cos(initialAngle);
        let yVector = Math.sin(initialAngle);
        //create the boid with the new data fields, and push to the boids array.
        let newBoid = new Boid(initialX, initialY, xVector, yVector);
        boids.push(newBoid);

    }
};
document.getElementById("clear").onclick = function () {
    //simply set the boids array to an empty array. I found that this was much more effective 
    //than trying to set up a for loop and "clear" each boid.
    boids = [];
};

let lastTime; // will be undefined by default
/**
 * The Actual Execution
 */
function loop(timestamp) {
    // time step - convert to 1/60th of a second frames
    // 1000ms / 60fps
    const delta = (lastTime ? timestamp - lastTime : 0) * 1000.0 / 60.0;

    // change directions
    boids.forEach(boid => boid.steer(boids, obstacles));
    // move forward
    let speed = Number(speedSlider.value);
    boids.forEach(function (boid) {
        boid.x += boid.vx * speed;
        boid.y += boid.vy * speed;
    });

    // now we can draw
    draw();
    // and loop
    window.requestAnimationFrame(loop);

}
// start the loop with the first iteration
window.requestAnimationFrame(loop);


/**
 * Add an eventListener for clicking - create flocking to the mouse when the mouse is pressed 
 */
canvas.addEventListener("click", function (event) {

    const mouseX = event.clientX - canvas.getBoundingClientRect().left;
    const mouseY = event.clientY - canvas.getBoundingClientRect().top;

    //ensure that all boids flock (i.e. forEach)
    boids.forEach(boid => {
        //calculate the difference between where the mouse is and where the boid is
        const horizMouseDist = mouseX - boid.x;
        const vertMouseDist = mouseY - boid.y;
        //calculate the distance using distance formula
        const distance = Math.sqrt(horizMouseDist * horizMouseDist + vertMouseDist * vertMouseDist);
        //if the boid has not yet reached the mouse, we want to update the horizontal and vertical velocity
        if (distance > 0) {
            // (!) THE NEXT TWO LINES OF CODE ( not comments ) WERE GENERATED BY CHAT GPT:
            //vx and vy are essentially unit vectors that are indicating what direction the boid travels 
            //in. Therefore, when we click with the mouse we must indicate what direction we are travelling in.
            //To do so, we can simply divide the (horizontal / vertical) vector by the distance because this
            //basically ensures that length of the direction vector is 1 (having a length of 1 allows us to
            //scale easily, preserve direction, among other things). This is called normalizing a vector.
            boid.vx = horizMouseDist / distance;
            boid.vy = vertMouseDist / distance;
        }
    });
});